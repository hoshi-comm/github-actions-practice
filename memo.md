# GitHub Actions 上で pytest を利用した自動テスト環境を構築経験


# pytestについて
- 細かい処理ロジックは sample.py / test_sample.py にある
- ci.yml は「いつ・どこで・どう実行するか」を決めるだけ指示書説明書的なもの








###  __pycache__ について  
- Python が .py ファイルを実行したとき、自動で「コンパイル済みのバイトコード」を __pycache__/ にキャッシュする

### .pytest_cache とは
- pytest が実行時に作るキャッシュ用ディレクトリ
- 前回のテスト結果とか、実行速度をちょっと上げるための情報が入ってる
- 不要ファイルだからリポジトリに入れる必要はない

# 実行したことについて
1.	テストしたい関数を用意する → OK（src/sample.py の add）
2.	pytestでテストを用意する → OK（tests/test_sample.py）
3.	ローカルでテストがpass → OK（1 passed 確認済み）    
4.	GitHub Actions用のyaml作成 → OK（.github/workflows/ci.yml 作成済み）
5.	コードをpushしてCIが通ることを確認 → これから

# CIとは/CIが通るとは
- CI = Continuous Integration（継続的インテグレーション） の略
- 直訳すると「継続的な統合」

- 何をするもの？
- 開発者がコードを こまめにリポジトリに統合（push/merge） する
- そのたびに 自動でテストやチェックを走らせる
- 「このコードはちゃんと動く」「壊れてない」をすぐ確認できる

- 「CIが通る」とは
- GitHub Actions（や他のCIサービス）がテストを実行
- すべて成功して緑チェック ✅ がつく状態
- 逆に失敗したら赤バツ ❌ で「この変更は何か壊してる」ってサイン

- なんでそんなことしてるか
- チーム開発だと「誰かのpushで他の人のコードが壊れた」を防げる
- 個人でも「コードが常に動く状態」を保証できる
- 実務ではCIが通らないとPRがマージできない運用が多い

👉 まとめると「CIが通る＝GitHub上で自動テストが走って成功した」ということ。
ローカルで動いたコードが、GitHub Actions 上でもちゃんと ✅ になるかを確認するのがゴールだね。
